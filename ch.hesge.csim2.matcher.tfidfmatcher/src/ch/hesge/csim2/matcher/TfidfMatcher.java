/**
 * 
 */
package ch.hesge.csim2.matcher;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealVector;

import ch.hesge.csim2.core.logic.ApplicationLogic;
import ch.hesge.csim2.core.model.Concept;
import ch.hesge.csim2.core.model.IMethodConceptMatcher;
import ch.hesge.csim2.core.model.MethodConceptMatch;
import ch.hesge.csim2.core.model.Project;
import ch.hesge.csim2.core.model.SourceMethod;
import ch.hesge.csim2.core.model.StemConcept;
import ch.hesge.csim2.core.model.StemMethod;
import ch.hesge.csim2.core.utils.SimpleMatrix;
import ch.hesge.csim2.core.utils.SimpleVector;

/**
 * This engine allow trace files generated by instrumentation to be loaded into
 * database.
 * test
 * Copyright HEG Geneva 2014, Switzerland
 * 
 * @author Eric Harth
 *
 */
public class TfidfMatcher implements IMethodConceptMatcher {

	/**
	 * Default constructor
	 */
	public TfidfMatcher() {
	}

	/**
	 * Get the engine name.
	 * @see ch.hesge.csim2.core.shell.IEngine#getName()
	 */
	@Override
	public String getName() {
		return "TfidfMatcher";
	}

	/**
	 * Get the engine version.
	 * @see ch.hesge.csim2.core.shell.IEngine#getVersion()
	 */
	@Override
	public String getVersion() {
		return "1.0.1";
	}

	/**
	 * Get the engine description
	 * @see ch.hesge.csim2.core.shell.IEngine#getDescription()
	 */
	@Override
	public String getDescription() {
		return "tfidf method concept matcher.";
	}

	/**
	 * Retrieve a map of all MethodConceptMatch classified by method Id.
	 * 
	 * @param project
	 *        the project where to calculate matching
	 * @return
	 *         a map of (MethodId, List<MethodConceptMatch>)
	 */
	public Map<Integer, List<MethodConceptMatch>> getMethodMatchingMap1(Project project) {

		List<MethodConceptMatch> matchings = new ArrayList<>();

		// Retrieve concept and method map
		Map<Integer, Concept> conceptMap = ApplicationLogic.getConceptMap(project);
		Map<Integer, SourceMethod> methodMap = ApplicationLogic.getSourceMethodMap(project);

		// Retrieve stem map
		Map<String, List<StemConcept>> stemConceptsMap = ApplicationLogic.getStemConceptByTermMap(project);
		Map<String, List<StemMethod>> stemMethodsMap = ApplicationLogic.getStemMethodByTermMap(project);

		// Get linear concepts and terms (matrix cols/rows)
		List<String> terms = new ArrayList<>(stemConceptsMap.keySet());
		List<Concept> concepts = new ArrayList<>(conceptMap.values());

		RealMatrix tfidfMatrix = getTfIdfMatrix1(terms, concepts, conceptMap, stemConceptsMap);

		// Calculate on term vectors for each method
		Map<Integer, RealVector> methodTermVectorMap = getMethodTermVectorMap1(terms, methodMap, stemMethodsMap);

		for (SourceMethod sourceMethod : methodMap.values()) {

			RealVector methodTermVector = methodTermVectorMap.get(sourceMethod.getKeyId());

			boolean isZeroVector = true;

			for (int i = 0; i < methodTermVector.getDimension(); i++) {
				if (methodTermVector.getEntry(i) != 0d) {
					isZeroVector = false;
					break;
				}
			}

			// Skip null method vector
			if (!isZeroVector) {

				// Select all concepts with similarity factor > 0
				for (int i = 0; i < tfidfMatrix.getColumnDimension(); i++) {

					Concept concept = concepts.get(i);
					RealVector conceptTermVector = tfidfMatrix.getColumnVector(i);

					// Calculate similarity between method and concept vectors
					double similarity = conceptTermVector.cosine(methodTermVector);

					// Register result within the matchMap
					if (similarity > 0d) {

						MethodConceptMatch match = new MethodConceptMatch();

						match.setProject(project);
						match.setSourceMethod(sourceMethod);
						match.setConcept(concept);
						match.setWeight(similarity);

						matchings.add(match);
					}
				}
			}
		}

		// Now build a map of concept matching, classified by method id
		Map<Integer, List<MethodConceptMatch>> matchingMap = new HashMap<>();

		for (MethodConceptMatch match : matchings) {

			// Create an associated array if missing
			if (!matchingMap.containsKey(match.getSourceMethod().getKeyId())) {
				matchingMap.put(match.getSourceMethod().getKeyId(), new ArrayList<>());
			}

			// Add the match to the array for the specific method
			matchingMap.get(match.getSourceMethod().getKeyId()).add(match);
		}

		return matchingMap;
	}

	/**
	 * Retrieve a map of term vector for each method passed in argument.
	 * Note: each vector component is based on term presence (1) or missing (0).
	 * 
	 * @param terms
	 *        the terms used to compute vectors
	 * @param concepts
	 *        the methods used to compute vectors
	 * @param stems
	 *        the stems allowing links between terms and methods
	 * @return
	 *         a map of all vectors associated to methods
	 */
	private static Map<Integer, RealVector> getMethodTermVectorMap1(List<String> terms, Map<Integer, SourceMethod> methods, Map<String, List<StemMethod>> stems) {

		Map<Integer, RealVector> methodTermVectorMap = new HashMap<>();

		// First fill ensure all methods are registered in map
		for (SourceMethod method : methods.values()) {
			methodTermVectorMap.put(method.getKeyId(), new ArrayRealVector(terms.size()));
		}

		// Now Loop over all terms
		for (int i = 0; i < terms.size(); i++) {

			// Retrieve current terms and stems
			String currentTerm = terms.get(i);

			// If at least one stem method is found, 
			// the ième coordinate should be 1.0. Otherwise, should be 0.0
			if (stems.containsKey(currentTerm)) {

				// Count each method referring the term
				for (StemMethod stem : stems.get(currentTerm)) {

					SourceMethod method = methods.get(stem.getSourceMethodId());

					// Update term counter in current concept vector
					methodTermVectorMap.get(method.getKeyId()).setEntry(i, 1d);
				}
			}
		}

		return methodTermVectorMap;
	}

	/**
	 * <pre>
	 * 
	 * Compute the tf-idf matrix based on terms and concepts passed in argument.
	 * 
	 * For instance:
	 * 
	 * 		  						+->  tf-idf weight for term T1, concept C2
	 * 								|
	 * 					|						|		
	 * 					|	0.3		3		0	|		T1		
	 * 		TF-IDF	=	|	1.5		0		7	|		T2		terms
	 * 					|	0		0		8	|		T3
	 * 					|	0		20		5	|		T4
	 * 					|						|
	 * 
	 * 						C1		C2		C3		--> concepts
	 * 
	 * 
	 * First, we compute the tf matrix (term = rows, concept = column).
	 * The tf-matrix represents the relative frequency of a term within a concept.
	 * 
	 * 	for a single term, and a single concept, tf is calculated as:
	 * 
	 *   					 	 	 term-occurrence-in-concept
	 *  		TF(i,j)		=		----------------------------  
	 *  					  	  		total-term-in-concept
	 *  
	 * 	
	 *   Then, we compute the idf matrix (term = rows, concept = column).
	 * 
	 *   The idf-matrix represents the inverse frequency of a term within a concept, weighted 
	 *  by the frequency of the term among the whole terms space.
	 * 
	 * 	for a single term, and a single concept, idf is calculated as:
	 * 
	 *  						       		total-term-count
	 *  		IDF(i,j)	=	log(  ----------------------------  )
	 *  						   		term-occurrence-in-concept
	 * 
	 * Finally the TFIDF matrix is calculated as:
	 * 
	 * 		TFIDF		=	TF	*	IDF
	 *
	 * </pre>
	 * 
	 * @param terms
	 *        the terms used to compute weights
	 * @param concepts
	 *        the concepts used to compute weights
	 * @param conceptMap
	 *        a map of all concepts classified by their keyId
	 * @param stems
	 *        the stems allowing links between terms and concepts
	 * @return
	 *         a tf-idf matrix
	 */
	private static RealMatrix getTfIdfMatrix1(List<String> terms, List<Concept> concepts, Map<Integer, Concept> conceptMap, Map<String, List<StemConcept>> stems) {

		// Prepare matrix/vectors used to perform tf and idf calculation
		RealMatrix termOccurrenceInConcept = MatrixUtils.createRealMatrix(terms.size(), concepts.size());
		RealVector totalTermInConcept = new ArrayRealVector(concepts.size());

		// Scan all terms and associated stems
		for (int i = 0; i < terms.size(); i++) {

			// Retrieve current term
			String term = terms.get(i);

			// Loop over all concepts referring a term
			for (StemConcept stem : stems.get(term)) {

				// Retrieve concept and index
				Concept concept = conceptMap.get(stem.getConceptId());
				int conceptIndex = concepts.indexOf(concept);

				// Count term occurrences in concept
				termOccurrenceInConcept.addToEntry(i, conceptIndex, 1d);

				// Adjust total term count in concept
				totalTermInConcept.addToEntry(conceptIndex, 1d);
			}
		}

		// Calculate the term frequency matrix
		RealMatrix tfMatrix = MatrixUtils.createRealMatrix(terms.size(), concepts.size());
		for (int i = 0; i < tfMatrix.getRowDimension(); i++) {
			RealVector occurrenceInConceptRow = termOccurrenceInConcept.getRowVector(i);
			tfMatrix.setRowVector(i, occurrenceInConceptRow.ebeDivide(totalTermInConcept));
		}

		// Calculate the inverse term frequency matrix
		RealMatrix idfMatrix = MatrixUtils.createRealMatrix(terms.size(), concepts.size());
		for (int i = 0; i < idfMatrix.getRowDimension(); i++) {
			RealVector occurrenceInConceptRow = termOccurrenceInConcept.getRowVector(i);
			for (int j = 0; j < occurrenceInConceptRow.getDimension(); j++) {
				double tfidf = Math.log10(((double) terms.size()) / (occurrenceInConceptRow.getEntry(j) + 1));
				idfMatrix.setEntry(i, j, tfidf);
			}
		}

		// Finally calculate tfidf = tf * idf (element-by-element)
		RealMatrix tfidfMatrix = MatrixUtils.createRealMatrix(terms.size(), concepts.size());
		for (int i = 0; i < tfMatrix.getRowDimension(); i++) {
			for (int j = 0; j < tfMatrix.getColumnDimension(); j++) {
				tfidfMatrix.setEntry(i, j, tfMatrix.getEntry(i, j) * idfMatrix.getEntry(i, j));
			}
		}

		return tfidfMatrix;
	}

	/**
	 * Retrieve a map of all MethodConceptMatch classified by method Id.
	 * 
	 * @param project
	 *        the project where to calculate matching
	 * @return
	 *         a map of (MethodId, List<MethodConceptMatch>)
	 */
	public Map<Integer, List<MethodConceptMatch>> getMethodMatchingMap(Project project) {

		List<MethodConceptMatch> matchings = new ArrayList<>();

		// Retrieve concept and method map
		Map<Integer, Concept> conceptMap = ApplicationLogic.getConceptMap(project);
		Map<Integer, SourceMethod> methodMap = ApplicationLogic.getSourceMethodMap(project);

		// Retrieve stem map
		Map<String, List<StemConcept>> stemConceptsMap = ApplicationLogic.getStemConceptByTermMap(project);
		Map<String, List<StemMethod>> stemMethodsMap = ApplicationLogic.getStemMethodByTermMap(project);

		// Get linear concepts and terms (matrix cols/rows)
		List<String> terms = new ArrayList<>(stemConceptsMap.keySet());
		List<Concept> concepts = new ArrayList<>(conceptMap.values());

		// Calculate term vector for each concept, i.e. a term-concept matrix
		SimpleMatrix tfidfMatrix = getTfIdfMatrix2(terms, concepts, conceptMap, stemConceptsMap);

		// Calculate on term vectors for each method
		Map<Integer, SimpleVector> methodTermVectorMap = getMethodTermVectorMap2(terms, methodMap, stemMethodsMap);

		for (SourceMethod sourceMethod : methodMap.values()) {

			SimpleVector methodTermVector = methodTermVectorMap.get(sourceMethod.getKeyId());

			// Skip null method vector
			if (!methodTermVector.isNullVector()) {

				// Select all concepts with similarity factor > 0
				for (int i = 0; i < tfidfMatrix.getColumnDimension(); i++) {

					Concept concept = concepts.get(i);
					SimpleVector conceptTermVector = tfidfMatrix.getColumnVector(i);

					// Calculate similarity between method and concept vectors
					double similarity = conceptTermVector.cosine(methodTermVector);

					// Register result within the matchMap
					if (similarity > 0d) {

						MethodConceptMatch match = new MethodConceptMatch();

						match.setProject(project);
						match.setSourceMethod(sourceMethod);
						match.setConcept(concept);
						match.setWeight(similarity);

						@SuppressWarnings("unchecked")
						List<StemConcept> stemConcepts = (List<StemConcept>) conceptTermVector.getData();
						match.getStemConcepts().addAll(stemConcepts);

						@SuppressWarnings("unchecked")
						List<StemMethod> stemMethods = (List<StemMethod>) methodTermVector.getData();
						match.getStemMethods().addAll(stemMethods);

						matchings.add(match);
					}
				}
			}
		}

		// Now build a map of concept matching, classified by method id
		Map<Integer, List<MethodConceptMatch>> matchingMap = new HashMap<>();

		for (MethodConceptMatch match : matchings) {

			// Create an associated array if missing
			if (!matchingMap.containsKey(match.getSourceMethod().getKeyId())) {
				matchingMap.put(match.getSourceMethod().getKeyId(), new ArrayList<>());
			}

			// Add the match to the array for the specific method
			matchingMap.get(match.getSourceMethod().getKeyId()).add(match);
		}

		return matchingMap;
	}

	/**
	 * Retrieve a map of term vector for each method passed in argument.
	 * Note: each vector component is based on term presence (1) or missing (0).
	 * 
	 * @param terms
	 *        the terms used to compute vectors
	 * @param concepts
	 *        the methods used to compute vectors
	 * @param stems
	 *        the stems allowing links between terms and methods
	 * @return
	 *         a map of all vectors associated to methods
	 */
	private static Map<Integer, SimpleVector> getMethodTermVectorMap2(List<String> terms, Map<Integer, SourceMethod> methods, Map<String, List<StemMethod>> stems) {

		Map<Integer, SimpleVector> methodTermVectorMap = new HashMap<>();

		// Ensure we have a vector for each method within the vector map
		for (SourceMethod method : methods.values()) {
			methodTermVectorMap.put(method.getKeyId(), new SimpleVector(terms.size()));
		}

		// Now Loop over all terms
		for (int i = 0; i < terms.size(); i++) {

			// Retrieve current terms and stems
			String currentTerm = terms.get(i);

			// If at least one stem method is found, 
			// the ième coordinate should be 1.0. Otherwise, should be 0.0
			if (stems.containsKey(currentTerm)) {

				// Count each method referring the term
				for (StemMethod stem : stems.get(currentTerm)) {

					SourceMethod method = methods.get(stem.getSourceMethodId());

					// Update term counter in current concept vector
					methodTermVectorMap.get(method.getKeyId()).addValue(i, 1d);
					methodTermVectorMap.get(method.getKeyId()).addData(i, stem);
				}
			}
		}

		return methodTermVectorMap;
	}

	/**
	 * <pre>
	 * 
	 * Compute the tf-idf matrix based on terms and concepts passed in argument.
	 * 
	 * For instance:
	 * 
	 * 		  						+->  tf-idf weight for term T1, concept C2
	 * 								|
	 * 					|						|		
	 * 					|	0.3		3		0	|		T1		
	 * 		TF-IDF	=	|	1.5		0		7	|		T2		terms
	 * 					|	0		0		8	|		T3
	 * 					|	0		20		5	|		T4
	 * 					|						|
	 * 
	 * 						C1		C2		C3		--> concepts
	 * 
	 * 
	 * First, we compute the tf matrix (term = rows, concept = column).
	 * The tf-matrix represents the relative frequency of a term within a concept.
	 * 
	 * 	for a single term, and a single concept, tf is calculated as:
	 * 
	 *   					 	 	 term-occurrence-in-concept
	 *  		TF(i,j)		=		----------------------------  
	 *  					  	  		total-term-in-concept
	 *  
	 * 	
	 *   Then, we compute the idf matrix (term = rows, concept = column).
	 * 
	 *   The idf-matrix represents the inverse frequency of a term within a concept, weighted 
	 *  by the frequency of the term among the whole terms space.
	 * 
	 * 	for a single term, and a single concept, idf is calculated as:
	 * 
	 *  						       		total-term-count
	 *  		IDF(i,j)	=	log(  ----------------------------  )
	 *  						   		term-occurrence-in-concept
	 * 
	 * Finally the TFIDF matrix is calculated as:
	 * 
	 * 		TFIDF		=	TF	*	IDF
	 *
	 * </pre>
	 * 
	 * @param terms
	 *        the terms used to compute weights
	 * @param concepts
	 *        the concepts used to compute weights
	 * @param conceptMap
	 *        a map of all concepts classified by their keyId
	 * @param stems
	 *        the stems allowing links between terms and concepts
	 * @return
	 *         a tf-idf matrix
	 */
	private static SimpleMatrix getTfIdfMatrix2(List<String> terms, List<Concept> concepts, Map<Integer, Concept> conceptMap, Map<String, List<StemConcept>> stems) {

		SimpleMatrix termOccurrenceInConcept = new SimpleMatrix(terms.size(), concepts.size());
		SimpleVector totalTermInConcept = new SimpleVector(concepts.size());

		// Scan all terms and build an occurrence matrix
		for (int i = 0; i < terms.size(); i++) {

			// Retrieve current term
			String term = terms.get(i);

			// Loop over all concepts referring a term
			for (StemConcept stem : stems.get(term)) {

				// Retrieve concept and index
				Concept concept = conceptMap.get(stem.getConceptId());
				int conceptIndex = concepts.indexOf(concept);

				// Count term occurrences in concept
				termOccurrenceInConcept.addValue(i, conceptIndex, 1d);
				termOccurrenceInConcept.addData(i, conceptIndex, stem);

				// Adjust total term count in concept
				totalTermInConcept.addValue(conceptIndex, 1d);
			}
		}

		SimpleMatrix tfMatrix = new SimpleMatrix(terms.size(), concepts.size());
		SimpleMatrix idfMatrix = new SimpleMatrix(terms.size(), concepts.size());
		SimpleMatrix tfidfMatrix = new SimpleMatrix(terms.size(), concepts.size());

		// Calculate the term frequency: tf = termOccurrenceInConcept / totalTermInConcept
		for (int i = 0; i < tfMatrix.getRowDimension(); i++) {
			SimpleVector occurrenceInConcept = termOccurrenceInConcept.getRowVector(i);
			tfMatrix.setRowVector(i, occurrenceInConcept.ebeDivide(totalTermInConcept));
		}

		// Calculate the inverse term frequency: idf = log(totalTermCount/(occurrenceInConcept+1)
		for (int i = 0; i < idfMatrix.getRowDimension(); i++) {
			SimpleVector totalTermCount = new SimpleVector(terms.size(), terms.size());
			SimpleVector occurrenceInConcept = termOccurrenceInConcept.getRowVector(i);
			occurrenceInConcept.ebeAdd(1d);
			idfMatrix.setRowVector(i, totalTermCount.ebeDivide(occurrenceInConcept));
		}
		idfMatrix = idfMatrix.log10();

		// Finally calculate final matrix: tfidf = tf * idf
		tfidfMatrix = tfMatrix.ebeMultiply(idfMatrix);

		return tfidfMatrix;
	}

}
