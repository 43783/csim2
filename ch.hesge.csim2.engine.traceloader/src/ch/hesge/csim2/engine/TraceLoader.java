/**
 * 
 */
package ch.hesge.csim2.engine;

import java.io.BufferedReader;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;
import java.util.Stack;

import ch.hesge.csim2.core.logic.ApplicationLogic;
import ch.hesge.csim2.core.model.Context;
import ch.hesge.csim2.core.model.IEngine;
import ch.hesge.csim2.core.model.Scenario;
import ch.hesge.csim2.core.model.Trace;
import ch.hesge.csim2.core.utils.Console;
import ch.hesge.csim2.core.utils.EngineException;
import ch.hesge.csim2.core.utils.StringUtils;

/**
 * This engine allow trace files generated by instrumentation to be loaded into
 * database.
 * 
 * Copyright HEG Geneva 2014, Switzerland
 * 
 * @author Eric Harth
 *
 */
public class TraceLoader implements IEngine {

	// Private attributes
	private Context context;

	private Path traceFile;
	private Scenario scenario;

	private Map<Long, Stack<Trace>> threadTraces;

	/**
	 * Default constructor
	 */
	public TraceLoader() {
		threadTraces = new Hashtable<>();
	}

	/**
	 * Get the engine name.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#getName()
	 */
	@Override
	public String getName() {
		return "TraceLoader";
	}

	/**
	 * Get the engine version.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#getVersion()
	 */
	@Override
	public String getVersion() {
		return "1.0.9";
	}

	/**
	 * Get the engine description
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#getDescription()
	 */
	@Override
	public String getDescription() {
		return "load a tracefile generated by an instrumentor.";
	}

	/**
	 * Return the parameter map required by the engine.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#getParameters()
	 */
	@Override
	public Properties getParameters() {

		Properties params = new Properties();

		params.put("scenario", "scenario");
		params.put("filename", "file");

		return params;
	}

	/**
	 * Retrieve the engine context.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#getContext()
	 */
	@Override
	public Context getContext() {
		return this.context;
	}

	/**
	 * Sets the engine context before starting.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#setContext()
	 */
	@Override
	public void setContext(Context context) {
		this.context = context;
	}

	/**
	 * Initialize the engine before starting.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#init()
	 */
	@Override
	public void init() {

		try {

			String inputFile = null;

			// Retrieve current scenario
			if (context.containsKey("scenario")) {
				scenario = (Scenario) context.getProperty("scenario");
			}
			else {
				throw new EngineException("missing scenario specified !");
			}

			// Retrieve input file
			if (context.containsKey("filename")) {
				inputFile = (String) context.getProperty("filename");
			}
			else {
				throw new EngineException("missing trace path specified !");
			}

			// Now, check if input file exists
			traceFile = Paths.get(inputFile).toAbsolutePath().normalize();
			if (!traceFile.toFile().exists()) {
				throw new EngineException("ontology file '" + traceFile + "' doesn't not exist !");
			}
		}
		catch (Exception e) {
			Console.writeError(this, "error while instrumenting files: " + StringUtils.toString(e));
		}
	}

	/**
	 * Start the engine.
	 * All trace lines are converted into Trace objects and inserted directly
	 * into the database.
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#start()
	 * 
	 */
	@Override
	public void start() {

		try {

			threadTraces.clear();
			ApplicationLogic.deleteTraces(scenario);

			int traceCounter = 0;
			int errorCounter = 0;
			int lineCounter = 1;

			BufferedReader reader = Files.newBufferedReader(traceFile, Charset.defaultCharset());
			String traceLine = null;

			while ((traceLine = reader.readLine()) != null) {

				// Retrieve trace object from string
				Trace trace = TraceLoaderUtils.parseTraceLine(traceLine);

				// Insert new trace in database
				if (trace != null) {

					Long threadId = Long.valueOf(trace.getThreadId());
					trace.setScenarioId(scenario.getKeyId());

					// Check for thread stack trace
					if (!threadTraces.containsKey(threadId)) {
						threadTraces.put(threadId, new Stack<Trace>());
					}

					// Retrieve current thread stack
					Stack<Trace> threadStack = threadTraces.get(threadId);

					// Trace entering, so create a new trace
					if (trace.isEnteringTrace()) {
						trace.setSequenceNumber(++traceCounter);
						ApplicationLogic.saveTrace(trace);
						threadStack.push(trace);
						Console.writeInfo(this, "  trace entering created: " + trace.getSequenceNumber());
					}

					// Trace exiting, so compute duration trace
					else {
						Trace popedTrace = threadStack.pop();
						long traceDuration = trace.getTimestamp() - popedTrace.getTimestamp();

						popedTrace.setDuration(traceDuration);
						ApplicationLogic.saveTrace(trace);

						trace.setSequenceNumber(++traceCounter);
						trace.setDuration(traceDuration);
						ApplicationLogic.saveTrace(trace);
						Console.writeInfo(this, "  trace exiting created:  " + trace.getSequenceNumber());
					}
				}

				// Otherwise show error line
				else {
					Console.writeError(this, " error in line: " + lineCounter + ", content: " + traceLine);
					errorCounter++;
				}

				lineCounter++;
			}

			Console.writeInfo(this, "TraceLoader report:");
			Console.writeInfo(this, "  parsed lines:   " + (lineCounter - 1));
			Console.writeInfo(this, "  trace created:  " + traceCounter);
			Console.writeInfo(this, "  error detected: " + errorCounter);
		}
		catch (Exception e) {
			Console.writeError(this, "unexpected error while parsing trace file: " + StringUtils.toString(e));
		}
	}

	/**
	 * Stop the engine
	 * 
	 * @see ch.hesge.csim2.core.shell.IEngine#stop()
	 */
	@Override
	public void stop() {
	}
}
